<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>My Book of Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="solid.html"><strong aria-hidden="true">4.</strong> SOLID Principles</a></li><li class="chapter-item expanded "><a href="bash_utils.html"><strong aria-hidden="true">5.</strong> Bash Utils</a></li><li class="chapter-item expanded "><a href="go_and_rust.html"><strong aria-hidden="true">6.</strong> Go and in Rust</a></li><li class="chapter-item expanded "><a href="raw_notes.html"><strong aria-hidden="true">7.</strong> Raw Notes</a></li><li class="chapter-item expanded "><a href="hashmap_1.html"><strong aria-hidden="true">8.</strong> Hashmap 1</a></li><li class="chapter-item expanded "><a href="functional.html"><strong aria-hidden="true">9.</strong> map,filter_map, collect</a></li><li class="chapter-item expanded "><a href="rust_aws_sdk_1.html"><strong aria-hidden="true">10.</strong> Rust AWS SDK 1</a></li><li class="chapter-item expanded "><a href="rust_repos.html"><strong aria-hidden="true">11.</strong> Repos to look at</a></li><li class="chapter-item expanded "><a href="100_questions.html"><strong aria-hidden="true">12.</strong> 100+ Questions</a></li><li class="chapter-item expanded "><a href="videos_1.html"><strong aria-hidden="true">13.</strong> Videos</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Book of Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<p>This book was created with <a href="https://github.com/rust-lang/mdBook">mdBook</a></p>
<p>It's very simple to create a book with rust, with
interactive code snippets.</p>
<p>Everything here is created in the folder <code>/theBook</code></p>
<h3 id="building-the-book"><a class="header" href="#building-the-book">Building the book</a></h3>
<p>Just run the following command:</p>
<pre><code class="language-bash">./build.sh
</code></pre>
<h3 id="to-work-on-it-interactive"><a class="header" href="#to-work-on-it-interactive">To Work on it Interactive</a></h3>
<pre><code class="language-bash">mdbook watch -o
</code></pre>
<p>Here's what's happening:</p>
<pre><code class="language-bash">mdbook build
rm -rf ../docs
mv book ../docs
</code></pre>
<p>And, that's it!  Here is the first example of
interactive code.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Some code
    println!(&quot;Hello, world!&quot;);
}</code></pre></pre>
<h3 id="a-more-advanced-example"><a class="header" href="#a-more-advanced-example">A more advanced example</a></h3>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! test {
    // Arguments don't need to be separated by a comma.
    // Any template can be used!
    ($left:expr; and $right:expr) =&gt; {
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    };
    // ^ each arm must end with a semicolon.
    ($left:expr; or $right:expr) =&gt; {
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    };
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}</code></pre></pre>
<h2 id="useful-basic-guide"><a class="header" href="#useful-basic-guide">Useful Basic Guide</a></h2>
<p>Sample with tests.</p>
<pre><pre class="playground"><code class="language-rust editable">fn add_integer(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn main() {
    println!(&quot;{}&quot;, add_integer(1, 2));
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_add_integer() {
        assert_eq!(super::add_integer(1, 2), 3);
    }
}

</code></pre></pre>
<h2 id="sample-with-fmt-skips"><a class="header" href="#sample-with-fmt-skips">Sample with fmt skips</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn vec_vec() -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    #[rustfmt::skip]
    let  vec = vec![
        vec![1, 2, 3],
        vec![4, 5, 6],
        vec![7, 8, 9],
    ];
    vec
}

fn main() {
    let vec = vec_vec();
    println!(&quot;{:?}&quot;, vec);
}</code></pre></pre>
<h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>This gets a little more complicated.  But, it's important.</p>
<p>We have to make sure all the variables have the same lifetime.</p>
<pre><pre class="playground"><code class="language-rust editable">fn greet&lt;'a&gt;(
    names: &amp;mut Vec&lt;&amp;'a str&gt;,
    target_name: &amp;'a str,
    custom_message: &amp;'a str,
    standard_message: &amp;'a str,
) {
    for name in names.iter_mut() {
        *name = match name {
            &amp;mut n if n == target_name =&gt; custom_message,
            _ =&gt; standard_message,
        }
    }
}

fn main() {
    let greeting = &quot;Well, hello Ferris!&quot;;
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];
    greet(&amp;mut names, &quot;Ferris&quot;, greeting, &quot;hi&quot;);
    println!(&quot;{:?}&quot;, names);
}

// Ref:
// https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/lifetimes.html</code></pre></pre>
<h1 id="working-with-files"><a class="header" href="#working-with-files">Working with Files</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::prelude::*;

fn read_file(path: &amp;str) -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}

fn modify_names(names: &amp;mut Vec&lt;&amp;str&gt;, custom_message: &amp;str) {
    names.iter_mut().for_each(|i| {
        let new_name = match *i {
            &quot;Bob&quot; =&gt; format!(&quot;{}!, What's happening?&quot;, *i),
            _ =&gt; format!(&quot;Hi {} {}&quot;, *i, custom_message),
        };
        *i = Box::leak(new_name.into_boxed_str());
    });
}

fn main() {
    match read_file(&quot;./data/file.txt&quot;) {
        Ok(contents) =&gt; {
            let mut lines = contents.lines().collect();
            modify_names(&amp;mut lines, &quot;, custom message!&quot;);
            println!(&quot;{:?}&quot;, lines);
        }
        Err(e) =&gt; panic!(&quot;Error reading file: {:?}&quot;, e),
    }
}</code></pre></pre>
<h1 id="working-with-errors"><a class="header" href="#working-with-errors">Working with Errors</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{Error, ErrorKind};

fn find(substring: &amp;str) -&gt; Result&lt;String, Error&gt; {
    let strings: Vec&lt;String&gt; = vec![
        &quot;apple&quot;.to_string(),
        &quot;banana&quot;.to_string(),
        &quot;cherry&quot;.to_string(),
    ];

    if let Some(s) = strings.iter().find(|s| s.contains(substring)) {
        println!(&quot;Found '{}' in '{}'&quot;, substring, s);
        Ok(s.to_string())
    } else {
        Err(Error::new(
            ErrorKind::NotFound,
            format!(&quot;No match for '{}'&quot;, substring),
        ))
    }
}

fn main() {
    let result = find(&quot;an&quot;);

    if result.is_err() {
        println!(&quot;Error: {:?}&quot;, result.err());
    } else {
        println!(&quot;Result: {:?}&quot;, result.unwrap());
    }
}

</code></pre></pre>
<h2 id="favorite"><a class="header" href="#favorite">Favorite</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![
        String::from(&quot;hello&quot;),
        String::from(&quot;world&quot;),
        String::from(&quot;bobcat&quot;),
        String::from(&quot;bob&quot;),
        String::from(&quot;alabama&quot;),
    ];

    let mut filtered_strings: Vec&lt;String&gt; = strings
        .iter()
        .filter(|s| s.contains(&quot;bob&quot;))
        .inspect(|s| println!(&quot;Filtered string: {:?}&quot;, s))
        .map(|s| s.clone())
        .collect();

    filtered_strings.sort();
    println!(&quot;Filtered strings: {:?}&quot;, filtered_strings);
}
</code></pre></pre>
<h2 id="heres-another-one"><a class="header" href="#heres-another-one">Here's another one</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![
        String::from(&quot;hello&quot;),
        String::from(&quot;world&quot;),
        String::from(&quot;bobcat&quot;),
        String::from(&quot;bob&quot;),
        String::from(&quot;alabama&quot;),
    ];

    let mut filtered_strings: Vec&lt;String&gt; = strings
        .iter()
        .filter_map(|s| {
            if s.contains(&quot;bob&quot;) {
                Some(s.clone())
            } else {
                None
            }
        })
        .collect();

    filtered_strings.sort();
    println!(&quot;Filtered strings: {:?}&quot;, filtered_strings);
}
</code></pre></pre>
<h2 id="useful"><a class="header" href="#useful">Useful</a></h2>
<p>This can also be useful</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    if let Some(third_number) = numbers.iter().nth(2) {
        println!(&quot;The third number is {}&quot;, third_number);
    } else {
        println!(&quot;There is no third number.&quot;);
    }
}

</code></pre></pre>
<h2 id="theres-more"><a class="header" href="#theres-more">There's more</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![
        String::from(&quot;hello&quot;),
        String::from(&quot;world&quot;),
        String::from(&quot;bobcat&quot;),
        String::from(&quot;bob&quot;),
        String::from(&quot;alabama&quot;),
    ];

    let mut filtered_strings: Vec&lt;String&gt; = strings
        .iter()
        .filter(|s| s.contains(&quot;bob&quot;))
        .inspect(|s| println!(&quot;Filtered string: {:?}&quot;, s))
        .filter(|s| sporky(s))
        .map(|s| s.clone())
        .collect();

    filtered_strings.sort();
    println!(&quot;Filtered strings: {:?}&quot;, filtered_strings);
}

fn sporky(string: &amp;str) -&gt; bool {
    if string.contains(&quot;cat&quot;) {
        println!(&quot;{} is sporky&quot;, string);
        true
    } else {
        println!(&quot;{} is not sporky&quot;, string);
        false
    }
}
</code></pre></pre>
<h2 id="you-gotta-love-maps"><a class="header" href="#you-gotta-love-maps">You gotta love maps</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![
        String::from(&quot;1 2 3 4&quot;),
        String::from(&quot;hello world&quot;),
        String::from(&quot;goodbye world&quot;),
        String::from(&quot;hello bobcat&quot;),
        String::from(&quot;goodbye bobcat&quot;),
        String::from(&quot;hello alabama&quot;),
        String::from(&quot;goodbye alabama&quot;),
    ];

    let filtered_strings: Vec&lt;String&gt; = strings
        .iter()
        .inspect(|s| println!(&quot;Before string: {:?}&quot;, s))
        .flat_map(|s| s.split_whitespace())
        .inspect(|s| println!(&quot;After string: {:?}&quot;, s))
        .filter(|s| s.contains(&quot;bob&quot;))
        .map(|s| s.to_owned())
        .collect();

    println!(&quot;Filtered strings: {:?}&quot;, filtered_strings);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h1>
<p>This is an example of chapter 2.</p>
<pre><pre class="playground"><code class="language-rust editable">enum Message {
    Quit,
    ChangeColor(u8, u8, u8),
    Move { x: i32, y: i32 },
    Write(String),
}

fn process_message(msg: Message) {
    // Using match expression
    match msg {
        Message::Quit =&gt; println!(&quot;Quit&quot;),
        Message::ChangeColor(r, g, b) =&gt; println!(&quot;Change color to ({}, {}, {})&quot;, r, g, b),
        Message::Move { x, y } =&gt; println!(&quot;Move to coordinates ({}, {})&quot;, x, y),
        Message::Write(text) =&gt; println!(&quot;Write: {}&quot;, text),
    }
}

fn main() {
    let msg1 = Message::ChangeColor(255, 0, 0);
    let msg2 = Message::Write(String::from(&quot;Hello, World!&quot;));
    let _msg3 = Message::Quit;
    let _msg4 = Message::Move { x: 10, y: 20 };

    // Using if let statement
    if let Message::ChangeColor(r, g, b) = msg1 {
        println!(&quot;Change color to ({}, {}, {})&quot;, r, g, b);
    } else {
        println!(&quot;Not a ChangeColor message&quot;);
    }

    process_message(msg1);
    process_message(msg2);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3"><a class="header" href="#chapter-3">Chapter 3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solid-principles"><a class="header" href="#solid-principles">SOLID Principles</a></h1>
<h2 id="dependency-inversion-principle"><a class="header" href="#dependency-inversion-principle">Dependency Inversion Principle</a></h2>
<h3 id="high-level-modules-should-not-depend-on-low-level-modules-both-should-depend-on-abstractions"><a class="header" href="#high-level-modules-should-not-depend-on-low-level-modules-both-should-depend-on-abstractions">High-level modules should not depend on low-level modules. Both should depend on abstractions.</a></h3>
<pre><pre class="playground"><code class="language-rust editable">// Define an abstraction (trait) for data storage
pub trait DataStorage {
    fn save_data(&amp;self, data: &amp;str) -&gt; Result&lt;(), String&gt;;
}

// Implement a low-level module for file storage
pub struct FileStorage;

impl DataStorage for FileStorage {
    fn save_data(&amp;self, data: &amp;str) -&gt; Result&lt;(), String&gt; {
        println!(&quot;Saving data to a file: {}&quot;, data);
        // Implement file saving logic here
        Ok(())
    }
}

// Implement another low-level module for cloud storage
pub struct CloudStorage;

impl DataStorage for CloudStorage {
    fn save_data(&amp;self, data: &amp;str) -&gt; Result&lt;(), String&gt; {
        println!(&quot;Saving data to the cloud: {}&quot;, data);
        // Implement cloud saving logic here
        Ok(())
    }
}

// High-level module that depends on the abstraction (trait) rather than concrete implementations
pub struct DataManager&lt;T: DataStorage&gt; {
    storage: T,
}

impl&lt;T: DataStorage&gt; DataManager&lt;T&gt; {
    pub fn new(storage: T) -&gt; Self {
        DataManager { storage }
    }

    pub fn save_data(&amp;self, data: &amp;str) -&gt; Result&lt;(), String&gt; {
        self.storage.save_data(data)
    }
}

fn main() {
    // Use FileStorage with DataManager
    let file_storage = FileStorage;
    let data_manager_file = DataManager::new(file_storage);
    data_manager_file.save_data(&quot;Some data for file storage&quot;).unwrap();

    // Use CloudStorage with DataManager
    let cloud_storage = CloudStorage;
    let data_manager_cloud = DataManager::new(cloud_storage);
    data_manager_cloud.save_data(&quot;Some data for cloud storage&quot;).unwrap();
}

</code></pre></pre>
<h2 id="dip-another-example"><a class="header" href="#dip-another-example">DIP Another example</a></h2>
<pre><pre class="playground"><code class="language-rust editable">pub trait Bird {
    fn bird_call(&amp;self);
}

pub struct Chicken {
    pub sound: String,
}

impl Bird for Chicken {
    fn bird_call(&amp;self) {
        println!(&quot;{}&quot;, self.sound);
    }
}

pub struct Duck {
    pub sound: String,
}

impl Bird for Duck {
    fn bird_call(&amp;self) {
        println!(&quot;{}&quot;, self.sound);
    }
}

pub struct BirdCage&lt;T: Bird&gt; {
    pub bird: T,
}

impl&lt;T: Bird&gt; BirdCage&lt;T&gt; {
    pub fn new(bird: T) -&gt; Self {
        Self { bird }
    }

    pub fn make_sound(&amp;self) {
        self.bird.bird_call();
    }
}

fn main() {
    let chicken = Chicken {
        sound: String::from(&quot;Cluck!&quot;),
    };
    let duck = Duck {
        sound: String::from(&quot;Quack!&quot;),
    };

    let chicken_cage = BirdCage::new(chicken);
    let duck_cage = BirdCage::new(duck);

    chicken_cage.make_sound();
    duck_cage.make_sound();
}</code></pre></pre>
<h2 id="dip-bank-example"><a class="header" href="#dip-bank-example">DIP bank example</a></h2>
<pre><pre class="playground"><code class="language-rust editable">pub trait Transaction {
    fn execute(&amp;self);
}

pub struct Deposit {
    pub amount: f64,
}

impl Transaction for Deposit {
    fn execute(&amp;self) {
        println!(&quot;Deposit: ${}&quot;, self.amount);
    }
}

pub struct Withdraw {
    pub amount: f64,
}

impl Transaction for Withdraw {
    fn execute(&amp;self) {
        println!(&quot;Withdraw: ${}&quot;, self.amount);
    }
}

pub struct Bank {
    pub transactions: Vec&lt;Box&lt;dyn Transaction&gt;&gt;,
}

impl Bank {
    pub fn new() -&gt; Self {
        Self { transactions: Vec::new() }
    }

    pub fn add_transaction&lt;T: Transaction + 'static&gt;(&amp;mut self, transaction: T) {
        self.transactions.push(Box::new(transaction));
    }

    pub fn process_transactions(&amp;self) {
        for transaction in &amp;self.transactions {
            transaction.execute();
        }
    }
}

fn main() {
    let deposit = Deposit { amount: 1000.0 };
    let withdraw = Withdraw { amount: 500.0 };

    let mut bank = Bank::new();
    bank.add_transaction(deposit);
    bank.add_transaction(withdraw);

    bank.process_transactions();
}</code></pre></pre>
<blockquote>
In this example, we have a Transaction trait that represents the abstraction, and two structs, Deposit and Withdraw, that implement the Transaction trait. The Bank struct is a high-level module that depends on the Transaction trait, an abstraction, rather than depending on the concrete implementations (Deposit and Withdraw).
</blockquote>
<blockquote>
The Bank struct maintains a vector of Box<dyn Transaction> to store transactions. This allows it to work with any kind of transaction without having to know the specifics of each type of transaction. The main function demonstrates the usage of the Bank struct with both a Deposit and a Withdraw instance.
</blockquote>
<blockquote>
The above example follows the Dependency Inversion Principle, as both high-level and low-level modules depend on an abstraction, and the abstraction does not depend on any implementation details.
</blockquote>
<h2 id="interface-segregation-principle"><a class="header" href="#interface-segregation-principle">Interface Segregation Principle</a></h2>
<h3 id="many-client-specific-interfaces-are-better-than-one-general-purpose-interface"><a class="header" href="#many-client-specific-interfaces-are-better-than-one-general-purpose-interface">Many client-specific interfaces are better than one general-purpose interface.</a></h3>
<pre><pre class="playground"><code class="language-rust editable">// Define smaller, more specific traits
trait Swimmer {
    fn swim(&amp;self);
}

trait Flyer {
    fn fly(&amp;self);
}

trait Walker {
    fn walk(&amp;self);
}

// Define the structs that will implement the traits
struct Penguin;
struct Duck;
struct Eagle;

// Implement the traits for each struct
impl Swimmer for Penguin {
    fn swim(&amp;self) {
        println!(&quot;Penguin swims.&quot;);
    }
}

impl Swimmer for Duck {
    fn swim(&amp;self) {
        println!(&quot;Duck swims.&quot;);
    }
}

impl Flyer for Duck {
    fn fly(&amp;self) {
        println!(&quot;Duck flies.&quot;);
    }
}

impl Flyer for Eagle {
    fn fly(&amp;self) {
        println!(&quot;Eagle flies.&quot;);
    }
}

impl Walker for Eagle {
    fn walk(&amp;self) {
        println!(&quot;Eagle walks.&quot;);
    }
}

// Use the specific traits in functions that require them
fn swim(swimmer: &amp;impl Swimmer) {
    swimmer.swim();
}

fn fly(flyer: &amp;impl Flyer) {
    flyer.fly();
}

fn walk(walker: &amp;impl Walker) {
    walker.walk();
}

// Main function
fn main() {
    let penguin = Penguin;
    let duck = Duck;
    let eagle = Eagle;

    swim(&amp;penguin);
    swim(&amp;duck);
    fly(&amp;duck);
    fly(&amp;eagle);
    walk(&amp;eagle);
}</code></pre></pre>
<h1 id="openclosed-principle"><a class="header" href="#openclosed-principle">Open/Closed Principle</a></h1>
<h2 id="software-entities-should-be-open-for-extension-but-closed-for-modification"><a class="header" href="#software-entities-should-be-open-for-extension-but-closed-for-modification">Software entities should be open for extension, but closed for modification.</a></h2>
<pre><pre class="playground"><code class="language-rust editable">// Define a trait `Shape` with a method `area`
pub trait Shape {
    fn area(&amp;self) -&gt; f64;
}

// Implement the `Shape` trait for a `Rectangle` struct
pub struct Rectangle {
    width: f64,
    height: f64,
}

impl Rectangle {
    pub fn new(width: f64, height: f64) -&gt; Self {
        Self { width, height }
    }
}

impl Shape for Rectangle {
    fn area(&amp;self) -&gt; f64 {
        self.width * self.height
    }
}

// Implement the `Shape` trait for a `Circle` struct
pub struct Circle {
    radius: f64,
}

impl Circle {
    pub fn new(radius: f64) -&gt; Self {
        Self { radius }
    }
}

impl Shape for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

// A function that calculates the total area of a list of shapes
pub fn total_area(shapes: &amp;[&amp;dyn Shape]) -&gt; f64 {
    shapes.iter().map(|shape| shape.area()).sum()
}

fn main() {
    let rectangle = Rectangle::new(5.0, 4.0);
    let circle = Circle::new(3.0);

    let shapes: Vec&lt;&amp;dyn Shape&gt; = vec![&amp;rectangle, &amp;circle];

    println!(&quot;Total area: {}&quot;, total_area(&amp;shapes));
}</code></pre></pre>
<h1 id="liskov-substitution-principle"><a class="header" href="#liskov-substitution-principle">Liskov Substitution Principle</a></h1>
<h2 id="subtypes-should-be-substitutable-for-their-base-types"><a class="header" href="#subtypes-should-be-substitutable-for-their-base-types">Subtypes should be substitutable for their base types.</a></h2>
<pre><pre class="playground"><code class="language-rust editable">pub trait Bird {
    fn fly(&amp;self);
}

pub struct Swallow {
    pub name: String,
}

impl Swallow {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
}

impl Bird for Swallow {
    fn fly(&amp;self) {
        println!(&quot;{} the Swallow is flying.&quot;, self.name);
    }
}

pub struct Penguin {
    pub name: String,
}

impl Penguin {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
}

impl Bird for Penguin {
    fn fly(&amp;self) {
        println!(&quot;{} the Penguin cannot fly.&quot;, self.name);
    }
}

pub fn let_birds_fly(birds: &amp;[&amp;dyn Bird]) {
    for bird in birds {
        bird.fly();
    }
}

fn main() {
    let swallow = Swallow::new(String::from(&quot;Jack&quot;));
    let penguin = Penguin::new(String::from(&quot;Penny&quot;));

    let birds: Vec&lt;&amp;dyn Bird&gt; = vec![&amp;swallow, &amp;penguin];

    let_birds_fly(&amp;birds);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bash-utils"><a class="header" href="#bash-utils">Bash Utils</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    let home_dir = env::var(&quot;HOME&quot;).expect(&quot;Failed to get user's home directory&quot;);
    let downloads_dir = format!(&quot;{}/Downloads&quot;, home_dir);
    let pdf_dir = format!(&quot;{}/pdf&quot;, downloads_dir);

    // Create the directory if it doesn't exist
    if let Err(_) = fs::create_dir_all(&amp;pdf_dir) {
        eprintln!(&quot;Failed to create directory: {}&quot;, pdf_dir);
        return;
    }

    let entries = match fs::read_dir(&amp;downloads_dir) {
        Ok(entries) =&gt; entries,
        Err(e) =&gt; {
            eprintln!(&quot;Failed to read directory: {}\nError: {}&quot;, downloads_dir, e);
            return;
        }
    };

    let mut file_count = 0;
    let mut total_bytes_moved = 0;

    for entry in entries {
        if let Ok(entry) = entry {
            let metadata = match entry.metadata() {
                Ok(metadata) =&gt; metadata,
                Err(e) =&gt; {
                    eprintln!(&quot;Failed to get metadata: {}&quot;, e);
                    continue;
                }
            };

            if metadata.is_file() {
                let file_name = entry.file_name();
                let file_name_str = file_name.to_string_lossy();

                if file_name_str.contains(&quot;pdf&quot;) {
                    let source_path = entry.path();
                    let destination_path = PathBuf::from(&amp;pdf_dir).join(file_name.clone());

                    match entry.metadata() {
                        Ok(metadata) =&gt; {
                            let file_size = metadata.len();

                            if let Err(e) = fs::rename(&amp;source_path, &amp;destination_path) {
                                eprintln!(&quot;Failed to move file: {}\nError: {}&quot;, file_name_str, e);
                            } else {
                                println!(&quot;Moved file: {}&quot;, file_name_str);
                                file_count += 1;
                                total_bytes_moved += file_size;
                            }
                        }
                        Err(e) =&gt; {
                            eprintln!(
                                &quot;Failed to get metadata for file: {}\nError: {}&quot;,
                                file_name_str, e
                            );
                        }
                    }
                }
            }
        }
    }

    println!(
        &quot;Moved {} file(s), total bytes: {}&quot;,
        file_count, total_bytes_moved
    );
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-and-in-rust"><a class="header" href="#go-and-in-rust">Go and in Rust</a></h1>
<p>So Go can do this... can Rust do this?</p>
<pre><code class="language-go">s := fmt.Sprintf(&quot;example: {}\n&quot;, &quot;text&quot;)
</code></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s = format!(&quot;example: {}\n&quot;, &quot;text&quot;);
    println!(&quot;{}&quot;, s);
}</code></pre></pre>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<h3 id="go-sample"><a class="header" href="#go-sample">Go Sample</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	m := map[string]string{
		&quot;key1&quot;: &quot;value1&quot;,
		&quot;key2&quot;: &quot;value2&quot;,
	}

	fmt.Println(m)
}

</code></pre>
<h3 id="rust-sample"><a class="header" href="#rust-sample">Rust Sample</a></h3>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

fn main() {
    let mut m: HashMap&lt;String, String&gt; = HashMap::new();
    m.insert(&quot;key1&quot;.to_string(), &quot;value1&quot;.to_string());
    m.insert(&quot;key2&quot;.to_string(), &quot;value2&quot;.to_string());

    println!(&quot;{:?}&quot;, m);
}</code></pre></pre>
<h2 id="append"><a class="header" href="#append">Append</a></h2>
<h3 id="go-sample-1"><a class="header" href="#go-sample-1">Go Sample</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	s := []string{}
	s = append(s,&quot;one&quot;)
	s = append(s,&quot;two&quot;)

	fmt.Println(s)
}

</code></pre>
<h3 id="rust-sample-1"><a class="header" href="#rust-sample-1">Rust Sample</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s: Vec&lt;String&gt; = Vec::new();
    s.push(&quot;one&quot;.to_string());
    s.push(&quot;two&quot;.to_string());

    println!(&quot;{:?}&quot;, s);
}
</code></pre></pre>
<h2 id="structs-and-recievers"><a class="header" href="#structs-and-recievers">Structs and Recievers</a></h2>
<h3 id="go-sample-2"><a class="header" href="#go-sample-2">Go Sample</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type K struct {
	name string
	age  float64
}

type S struct {
	Name string
	b    []K
}

func (s *S) Get(name string) float64 {
	for _, v := range s.b {
		if v.name == name {
			return v.age
		}

	}
	return -1
}

func (s *S) Put(name string, age float64) {
	if s.b == nil {
		s.b = make([]K, 0)

	}
	s.b = append(s.b, K{name, age})

}

func main() {
	s := &amp;S{&quot;Bob&quot;, nil}
	s.Put(&quot;Bob&quot;, 12)
	s.Put(&quot;Alice&quot;, 13)
	fmt.Println(&quot;bob's age: &quot;, s.Get(&quot;Bob&quot;))

	fmt.Println(s)

}

</code></pre>
<h3 id="rust-sample-2"><a class="header" href="#rust-sample-2">Rust Sample</a></h3>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct K {
    name: String,
    age: f64,
}

#[derive(Debug)]
struct S {
    name: String,
    b: Vec&lt;K&gt;,
}

impl S {
    fn new(name: &amp;str) -&gt; Self {
        S {
            name: name.to_string(),
            b: Vec::new(),
        }
    }

    fn get(&amp;self, name: &amp;str) -&gt; f64 {
        for k in &amp;self.b {
            if k.name == name {
                return k.age;
            }
        }
        -1.0
    }

    fn put(&amp;mut self, name: &amp;str, age: f64) {
        self.b.push(K {
            name: name.to_string(),
            age,
        });
    }
}

fn main() {
    let mut s = S::new(&quot;Bob&quot;);
    s.put(&quot;Bob&quot;, 12.0);
    s.put(&quot;Alice&quot;, 13.0);
    println!(&quot;bob's age: {:?}&quot;, s.get(&quot;Bob&quot;));

    println!(&quot;{:?}&quot;, s);
}

</code></pre></pre>
<p>What about Go's defer?</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    defer(|| {
        println!(&quot;This message always gets printed last!&quot;);
    });

    panic!(&quot;Oops, something went wrong!&quot;);
}

fn defer&lt;F: FnOnce() + 'static&gt;(f: F) {
    let deferrer = Defer { f: Some(f) };
    std::mem::forget(deferrer);
}

struct Defer&lt;F: FnOnce() + 'static&gt; {
    f: Option&lt;F&gt;,
}

impl&lt;F: FnOnce() + 'static&gt; Drop for Defer&lt;F&gt; {
    fn drop(&amp;mut self) {
        if let Some(f) = self.f.take() {
            let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(f));
        }
    }
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-notes"><a class="header" href="#raw-notes">Raw Notes</a></h1>
<p>Daily progress notes, in no particular order.</p>
<h2 id="2023-03-04"><a class="header" href="#2023-03-04">2023-03-04</a></h2>
<p>Write a Rust program each day, for 100 days.</p>
<pre><pre class="playground"><code class="language-rust editable">
fn add(a:&amp;mut i32, b: i32) -&gt; i32 {
    *a += b;
    *a
}

fn main() {
    let mut x = 5;
    println!(&quot;{}\n&quot;, add(&amp;mut x, 2));
    let mut y = add(&amp;mut x, 20);
    println!(&quot;{}\n&quot;, add(&amp;mut y, 2));    
}  </code></pre></pre>
<p>It's also possible to add Go code. But, this
code won't execute.</p>
<pre><code class="language-go editable">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello, playground&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap-1"><a class="header" href="#hashmap-1">Hashmap 1</a></h1>
<pre><pre class="playground"><code class="language-rust editable">
use std::collections::HashMap;

fn create_hashmap() -&gt; Box&lt;HashMap&lt;i32, String&gt;&gt; {
    let mut map = HashMap::new();
    map.insert(1, &quot;hello&quot;.to_string());
    map.insert(2, &quot;world&quot;.to_string());

    Box::new(map)
}

fn add_to_boxed_hashmap(box_map: &amp;mut Box&lt;HashMap&lt;i32, String&gt;&gt;, key: i32, value: String) {
    for i in 0..10 {
        box_map.insert(i, format!(&quot;hello {}&quot;, i));
    }
    box_map.insert(key, value);
}

fn main() {
    let mut box_map = create_hashmap();
    add_to_boxed_hashmap(&amp;mut box_map, 0, &quot;foo&quot;.to_string());
    println!(&quot;{:?}&quot;, box_map);
}


</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapfilter_map-collect"><a class="header" href="#mapfilter_map-collect">map,filter_map, collect</a></h1>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    let r = names
        .iter()
        .filter_map(|name| match name.starts_with(&quot;F&quot;) {
            true =&gt; Some(name),
            false =&gt; None,
        })
        .map(|name| name.to_uppercase())
        .collect::&lt;Vec&lt;String&gt;&gt;();

    println!(&quot;{:?}&quot;, r);
}

</code></pre></pre>
<p>Here's a more complicated example.  This is a common pattern in Rust.</p>
<pre><pre class="playground"><code class="language-rust editable">fn modify_names(names: &amp;mut Vec&lt;&amp;str&gt;) {
    names.iter_mut().for_each(|i| {
        let new_name = match *i {
            &quot;Bob&quot; =&gt; format!(&quot;{}!, What's happening?&quot;, *i),
            _ =&gt; format!(&quot;Hi {}&quot;, *i),
        };
        *i = Box::leak(new_name.into_boxed_str());
    });
}

fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    modify_names(&amp;mut names);

    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<p>And you can add a custom message.</p>
<pre><pre class="playground"><code class="language-rust editable">fn modify_names(names: &amp;mut Vec&lt;&amp;str&gt;,custom_message: &amp;str) {
    names.iter_mut().for_each(|i| {
        let new_name = match *i {
            &quot;Bob&quot; =&gt; format!(&quot;{}!, What's happening?&quot;, *i),
            _ =&gt; format!(&quot;Hi {} {}&quot;, *i,custom_message),
        };
        *i = Box::leak(new_name.into_boxed_str());
    });
}

fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    modify_names(&amp;mut names,&quot;, custom message!&quot;);

    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-aws-sdk-1"><a class="header" href="#rust-aws-sdk-1">Rust AWS SDK 1</a></h1>
<p>See <a href="https://github.com/cwxstat/rust_daily/tree/main/each_day/day29">day29</a> for a complete example.</p>
<pre><code class="language-bash">cargo add aws-sdk-sqs
</code></pre>
<p>References:
<a href="https://crates.io/crates/aws-sdk-sqs">https://crates.io/crates/aws-sdk-sqs</a></p>
<p><a href="https://awslabs.github.io/aws-sdk-rust/">https://awslabs.github.io/aws-sdk-rust/</a></p>
<p><a href="https://crates.io/">https://crates.io/</a></p>
<p><a href="https://crates.io/crates/tokio">https://crates.io/crates/tokio</a></p>
<p><a href="https://github.com/tokio-rs/mini-redis">https://github.com/tokio-rs/mini-redis</a></p>
<pre><code class="language-bash">[dependencies]
aws-config = &quot;0.54.1&quot;
aws-sdk-sqs = &quot;0.24.0&quot;
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repos-to-look-at"><a class="header" href="#repos-to-look-at">Repos to look at</a></h1>
<p><a href="https://github.com/awslabs/aws-sdk-rust">https://github.com/awslabs/aws-sdk-rust</a></p>
<p><a href="https://awslabs.github.io/aws-sdk-rust/">https://awslabs.github.io/aws-sdk-rust/</a></p>
<p>References:
<a href="https://crates.io/crates/aws-sdk-sqs">https://crates.io/crates/aws-sdk-sqs</a></p>
<p><a href="https://awslabs.github.io/aws-sdk-rust/">https://awslabs.github.io/aws-sdk-rust/</a></p>
<p><a href="https://crates.io/">https://crates.io/</a></p>
<p><a href="https://crates.io/crates/tokio">https://crates.io/crates/tokio</a></p>
<p><a href="https://github.com/tokio-rs/mini-redis">https://github.com/tokio-rs/mini-redis</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="100-questions"><a class="header" href="#100-questions">100+ Questions</a></h1>
<ul>
<li>
<p>What is Rust and what makes it unique?</p>
</li>
<li>
<p>What are the advantages of using Rust over other languages?</p>
</li>
<li>
<p>Explain the concepts of ownership, borrowing, and lifetimes in Rust.</p>
</li>
<li>
<p>What is a variable shadowing in Rust?</p>
</li>
<li>
<p>What is the difference between mutable and immutable variables?</p>
</li>
<li>
<p>How is memory safety ensured in Rust?</p>
</li>
<li>
<p>What is the borrow checker and how does it work?</p>
</li>
<li>
<p>What are the differences between a slice and an array in Rust?</p>
</li>
<li>
<p>How do you define a function in Rust?</p>
</li>
<li>
<p>What is pattern matching and how is it used in Rust?</p>
</li>
<li>
<p>What is a tuple and how does it differ from an array?</p>
</li>
<li>
<p>What is the match expression and how does it work?</p>
</li>
<li>
<p>What are enums and how do you use them?</p>
</li>
<li>
<p>Explain the concept of structs in Rust.</p>
</li>
<li>
<p>How do you implement methods for a struct?</p>
</li>
<li>
<p>What are traits and how are they used in Rust?</p>
</li>
<li>
<p>What are the differences between a trait and an interface in other languages?</p>
</li>
<li>
<p>What is a module in Rust and how do you create one?</p>
</li>
<li>
<p>How do you handle errors in Rust?</p>
</li>
<li>
<p>Explain the difference between panic and Result.</p>
</li>
<li>
<p>What is the Option type and when should you use it?</p>
</li>
<li>
<p>What is an iterator in Rust and how do you create one?</p>
</li>
<li>
<p>How do you work with strings in Rust?</p>
</li>
<li>
<p>What is the difference between a String and a &amp;str in Rust?</p>
</li>
<li>
<p>How do you implement generics in Rust?</p>
</li>
<li>
<p>What is a macro in Rust and how do you define one?</p>
</li>
<li>
<p>Explain the differences between macros and functions.</p>
</li>
<li>
<p>What is the standard library and what are some of its components?</p>
</li>
<li>
<p>How does Rust handle concurrency?</p>
</li>
<li>
<p>What is the difference between threads and tasks in Rust?</p>
</li>
<li>
<p>Explain the concept of async/await in Rust.</p>
</li>
<li>
<p>What is a closure and how does it work in Rust?</p>
</li>
<li>
<p>What are the differences between a closure and a function?</p>
</li>
<li>
<p>How do you work with files and directories in Rust?</p>
</li>
<li>
<p>Explain the concept of a Result type and its use cases.</p>
</li>
<li>
<p>How do you perform error propagation in Rust?
-- What is the difference between a Vec and an array in Rust?</p>
</li>
<li>
<p>What is a HashMap and how do you use it in Rust?</p>
</li>
<li>
<p>Explain the concept of reference counting in Rust.</p>
</li>
<li>
<p>What are the differences between Arc and Rc?</p>
</li>
<li>
<p>What is a smart pointer and how does it work in Rust?</p>
</li>
<li>
<p>Explain the concept of interior mutability in Rust.</p>
</li>
<li>
<p>What are the differences between Cell and RefCell?</p>
</li>
<li>
<p>How does Rust handle null values?</p>
</li>
<li>
<p>What is the difference between PartialEq and Eq?</p>
</li>
<li>
<p>What is a type alias and how do you create one?</p>
</li>
<li>
<p>Explain the concept of associated types in Rust.</p>
</li>
<li>
<p>What is an associated function and how do you define one?</p>
</li>
<li>
<p>How do you implement multiple traits for a single type?</p>
</li>
<li>
<p>What is the purpose of the drop function in Rust?</p>
</li>
<li>
<p>Explain the concept of the Deref trait.</p>
</li>
<li>
<p>What is the purpose of the PhantomData type?</p>
</li>
<li>
<p>What is the difference between Send and Sync?</p>
</li>
<li>
<p>Explain the concept of unsafe code in Rust.</p>
</li>
<li>
<p>What is a raw pointer and how do you use it?</p>
</li>
<li>
<p>How do you define a constant in Rust?</p>
</li>
<li>
<p>What is a static variable and how do you define one?</p>
</li>
<li>
<p>What is a lazy_static and when should you use it?</p>
</li>
<li>
<p>How do you define and use custom error types in Rust?</p>
</li>
<li>
<p>What is the difference between Clone and Copy traits?</p>
</li>
<li>
<p>What is a lifetime and why is it important in Rust?</p>
</li>
<li>
<p>How do you specify lifetime annotations in Rust?</p>
</li>
<li>
<p>What is the 'static lifetime and when is it used?</p>
</li>
<li>
<p>What is the purpose of the Sized trait?</p>
</li>
<li>
<p>Explain the concept of type erasure in Rust.</p>
</li>
<li>
<p>How do you use cargo and what is its purpose?</p>
</li>
<li>
<p>How do you create and use a dependency in a Rust project?</p>
</li>
<li>
<p>What is a workspace in Cargo and how do you create one?</p>
</li>
<li>
<p>Explain the concept of conditional compilation in Rust.</p>
</li>
<li>
<p>What is a build script and how do you use it in a Rust project?</p>
</li>
<li>
<p>What is a feature flag and how do you use it in Rust?</p>
</li>
<li>
<p>Explain the concept of testing in Rust.</p>
</li>
<li>
<p>How do you write unit tests and integration tests in Rust?</p>
</li>
<li>
<p>What is the purpose of the #[cfg(test)] attribute?</p>
</li>
<li>
<p>How do you perform benchmarking in Rust?</p>
</li>
<li>
<p>What is the difference between a no_std and a std Rust project?</p>
</li>
<li>
<p>How do you compile Rust code to WebAssembly?</p>
</li>
<li>
<p>What is serde and how do you use it in Rust?</p>
</li>
<li>
<p>How do you implement serialization and deserialization in Rust?</p>
</li>
<li>
<p>Explain the concept of FFI (Foreign Function Interface) in Rust.</p>
</li>
<li>
<p>How do you call C code from Rust and vice versa?</p>
</li>
<li>
<p>What is the purpose of the Pin type in Rust?</p>
</li>
<li>
<p>Explain the concept of zero-cost abstractions in Rust.</p>
</li>
<li>
<p>What is the difference between a Box, a Rc, and an Arc?</p>
</li>
</ul>
<blockquote>
Box: A Box provides heap allocation for a single value. It is useful when you want to allocate data on the heap rather than the stack. In this example, we create a Box containing a Foo instance and print its value.
</blockquote>
<blockquote>
Rc (Reference Counting): Rc is used when you want to share ownership of an instance across multiple parts of your code. It tracks the number of references to an instance and deallocates the memory when the reference count goes down to zero. In this example, we create an Rc containing a Foo instance, clone it, and print the value of both the original Rc and the clone.
</blockquote>
<blockquote>
Arc (Atomic Reference Counting): Arc is similar to Rc, but it is thread-safe, allowing shared ownership across multiple threads. It uses atomic operations to manage the reference count, which makes it safe to use concurrently. In this example, we create an Arc containing a Foo instance, clone it, spawn a new thread that uses the cloned instance, and print the value of both the original Arc and the clone in the new thread.
</blockquote>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;
use std::sync::Arc;
use std::thread;

struct Foo {
    value: i32,
}

fn main() {
    // Box
    let foo_box = Box::new(Foo { value: 42 });
    println!(&quot;Box value: {}&quot;, foo_box.value);

    // Rc (Reference Counting)
    let foo_rc = Rc::new(Foo { value: 42 });
    let foo_rc_clone = Rc::clone(&amp;foo_rc);
    println!(&quot;Rc value: {}&quot;, foo_rc.value);
    println!(&quot;Rc clone value: {}&quot;, foo_rc_clone.value);

    // Arc (Atomic Reference Counting)
    let foo_arc = Arc::new(Foo { value: 42 });
    let foo_arc_clone = Arc::clone(&amp;foo_arc);

    let handle = thread::spawn(move || {
        println!(&quot;Arc value in thread: {}&quot;, foo_arc_clone.value);
    });

    println!(&quot;Arc value: {}&quot;, foo_arc.value);

    handle.join().unwrap();
}

</code></pre></pre>
<ul>
<li>What is a Mutex and how do you use it in Rust?</li>
<li>What is a RwLock and how do you use it in Rust?</li>
<li>How do you implement a custom iterator in Rust?</li>
<li>What is the purpose of the From and Into traits?</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Meter(u32);

#[derive(Debug)]
struct Feet(u32);

// Implementing the From trait for converting Feet into Meter
impl From&lt;Feet&gt; for Meter {
    fn from(feet: Feet) -&gt; Self {
        Meter((feet.0 as f32 * 0.3048) as u32)
    }
}

// Implementing the Into trait for converting Meter into Feet
impl Into&lt;Feet&gt; for Meter {
    fn into(self) -&gt; Feet {
        Feet((self.0 as f32 * 3.28084) as u32)
    }
}

fn main() {
    // Using the From trait
    let feet = Feet(100);
    let meter: Meter = Meter::from(feet);
    println!(&quot;100 feet is equal to {:?} meters&quot;, meter);

    // Using the Into trait
    let meter = Meter(30);
    let feet: Feet = meter.into();
    println!(&quot;30 meters is equal to {:?} feet&quot;, feet);
}
</code></pre></pre>
<ul>
<li>What is the difference between a ref and a ref mut in Rust?</li>
<li>How do you use conditional statements in Rust?</li>
<li>What are the different types of loops in Rust and how do you use them?</li>
<li>Explain the concept of a tuple struct in Rust.</li>
<li>How do you implement a recursive function in Rust?</li>
<li>What is the difference between a function and a method in Rust?</li>
<li>What is a constructor and how do you create one in Rust?</li>
<li>Explain the concept of type inference in Rust.</li>
<li>What is the purpose of the AsRef and AsMut traits?</li>
<li>What is a nightly build of Rust and when should you use it?</li>
<li>What are the different editions of Rust and how do they differ?</li>
<li>What resources do you recommend for learning Rust?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="videos"><a class="header" href="#videos">Videos</a></h1>
<p><a href="https://youtu.be/ugz1YgoZmzI?list=PLmsFUfdnGr3ynWvqEn4ffoMnT6WQ5E3-y&amp;t=2873">Island Problem</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
